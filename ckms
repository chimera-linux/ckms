#!/usr/bin/env python3

import os
import sys
import shutil
import pathlib
import argparse
import traceback
import subprocess
import contextlib
import configparser

kern_path = pathlib.Path("/lib/modules")

# initial values, but after parsing cfg they will be pathlib.Path
opt_rootdir = "/var/lib/ckms"
opt_destdir = str(kern_path)

opt_confpath = "/etc/ckms/config.ini"
opt_stripbin = "strip"
opt_kernver = None
opt_modconf = None
opt_quiet = False
opt_depmod = True
opt_arch = None
opt_jobs = None
opt_comp = None

use_colors = True

@contextlib.contextmanager
def redir_allout(logpath):
    try:
        # save old descriptors
        oldout = os.dup(sys.stdout.fileno())
        olderr = os.dup(sys.stderr.fileno())
        if opt_quiet:
            # quiet mode: just get all stdout/stderr into logfile
            logfile = open(logpath, "wb")
            os.dup2(logfile.fileno(), sys.stdout.fileno())
            os.dup2(logfile.fileno(), sys.stderr.fileno())
        else:
            # this will do the logging for us; this way we can get
            # both standard output and file redirection at once
            tee = subprocess.Popen(["tee", logpath], stdin = subprocess.PIPE)
            # everything goes into the pipe
            os.dup2(tee.stdin.fileno(), sys.stdout.fileno())
            os.dup2(tee.stdin.fileno(), sys.stderr.fileno())
        # fire
        yield
    finally:
        # restore
        os.dup2(oldout, sys.stdout.fileno())
        os.dup2(olderr, sys.stderr.fileno())
        if not opt_quiet:
            # close the pipe
            tee.stdin.close()
        else:
            logfile.close()
        # close the old duplicates
        os.close(oldout)
        os.close(olderr)
        if not opt_quiet:
            # wait for the tee to finish
            tee.communicate()

class CkmsError(Exception):
    pass

def log(msg, col = "\033[1m"):
    if use_colors:
        sys.stdout.write(col)
    sys.stdout.write("=> ckms: ")
    sys.stdout.write(msg)
    if use_colors:
        sys.stdout.write("\033[m")
    sys.stdout.write("\n");

def log_red(msg):
    log(msg, "\033[1m\033[31m")

def drop_privs():
    if os.geteuid() != 0:
        return
    # drop privileges to owner of state directory
    st = opt_rootdir.stat()
    os.setgid(st.st_gid)
    os.setuid(st.st_uid)

def check_has_action(cmd, drop_priv = True):
    if len(cmd) < 2:
        raise CkmsError("action argument not given")

    if drop_priv:
        drop_privs()

class Module:
    def __init__(self, name, version, modpath, modconf, cfgdata):
        self.name = name
        self.version = version
        self.modver = f"{name}={version}"
        self.cfgdata = cfgdata
        self.modpath = modpath
        self.modconf = modconf
        try:
            self.strip = cfgdata["general"].getboolean("strip", fallback = True)
        except ValueError:
            raise CkmsError("invalid value for 'strip'")
        # determine make implementation, default to gnu make
        maken = cfgdata["general"].get("make", fallback = "gmake")
        if not shutil.which(maken):
            do_fail = True
            if maken == "gmake":
                try:
                    # check if our regular make is okay enough
                    do_fail = not subprocess.run(
                        ["make", "--version"], capture_output = True
                    ).stdout.startswith(b"GNU Make")
                except Exception:
                    pass
            if do_fail:
                raise CkmsError(f"make not present: {maken}")
            else:
                self.make = "make"
        else:
            self.make = maken
        # default environment
        self.env = {
            "PATH": os.environ["PATH"],
            "MAKE": self.make,
            "SHELL": "/bin/sh",
            "CKMS_MODNAME": name,
            "CKMS_MODVERSION": version,
            "CKMS_JOBS": str(opt_jobs),
            "CKMS_ROOTDIR": str(opt_rootdir),
            "CKMS_DESTDIR": str(opt_destdir),
        }
        if opt_depmod:
            self.env["CKMS_DEPMOD"] = "1"
        # save a list of modules
        self.modules = []
        modset = {}
        for sect in cfgdata.sections():
            if not sect.startswith("module."):
                continue
            sh = cfgdata[sect]
            mn = sect.removeprefix("module.")
            if "path" not in sh or "dest" not in sh:
                raise CkmsError(f"malformed module section '{sect}'")
            if mn in modset:
                raise CkmsError(f"duplicate module '{mn}'")
            strip = None
            if "strip" in sh:
                try:
                    strip = sh.getboolean("strip")
                except ValueError:
                    raise CkmsError(f"invalid value for 'strip' for '{mn}'")
            self.modules.append((mn, sh["path"], sh["dest"], strip))
        # make deterministic
        self.modules.sort(key = lambda v: v[0])
        # ensure we have some modules
        if len(self.modules) == 0:
            raise CkmsError(f"'{self.name}' has no kernel modules")

    def ensure_builtins(self, kerndir, kernarch, kernver):
        gen = self.cfgdata["general"]
        gen["kernel_hdrdir"] = str(kerndir)
        gen["kernel_arch"] = kernarch
        gen["kernel_version"] = kernver
        # expose for hooks
        self.env["CKMS_KERNEL_HDRDIR"] = str(kerndir)
        self.env["CKMS_KERNEL"] = kernver
        self.env["CKMS_ARCH"] = kernarch

    def shell(self, s, cwd = None):
        if not cwd:
            cwd = self.modpath / "build"
        return subprocess.run(
            s, shell = True, cwd = cwd, env = self.env
        )

    def do(self, cmd, *args, cwd = None):
        if not cwd:
            cwd = self.modpath / "build"
        return subprocess.run(
            [cmd, *args], cwd = cwd, env = self.env
        )

    def run_hook(self, hookn):
        if "hooks" not in self.cfgdata:
            return False
        if hookn not in self.cfgdata["hooks"]:
            return False
        (self.modpath / "logs").mkdir(exist_ok = True, parents = True)
        # redirect output into logfile as necessary
        with redir_allout(self.modpath / f"logs/{hookn}.log"):
            pret = self.shell(self.cfgdata["hooks"][hookn])
        if pret.returncode != 0:
            raise CkmsError(
                f"hook '{hookn}' failed with code {pret.returncode}"
            )
        return True

def get_modpath(namever):
    eq = namever.find("=")

    if eq < 0:
        p = pathlib.Path(namever)
        if p.is_dir() and p.parent.parent == opt_rootdir:
            if (p / "source").is_dir():
                return p
        raise CkmsError(f"'{namever}' does not match format 'name=version'")

    name = namever[0:eq]
    ver = namever[eq + 1:]

    if len(name) == 0 or len(ver) == 0:
        raise CkmsError(f"'{namever}' does not match format 'name=version'")

    return opt_rootdir / name / ver

def read_module(modpath, by_name = False):
    if by_name:
        modpath = get_modpath(modpath) / "source"
    else:
        modpath = pathlib.Path(modpath)

    if not modpath.is_dir():
        raise CkmsError(f"module path '{cmd[1]}' does not exist")

    modconf = opt_modconf
    if not modconf:
        if by_name:
            modconf = modpath.parent / "ckms.ini"
        else:
            modconf = modpath / "ckms.ini"

    modconf = pathlib.Path(modconf)

    if not modconf.is_file():
        raise CkmsError(f"module config file not found for '{cmd[1]}'")

    mcfg = configparser.ConfigParser(default_section = "general")
    mcfg.read(modconf)

    if "general" not in mcfg:
        raise CkmsError(f"general section missing for '{modconf}'")

    gen = mcfg["general"]

    if "name" not in gen:
        raise CkmsError(f"module name unknown for '{modconf}'")
    if "version" not in gen:
        raise CkmsError(f"module version unknown for '{modconf}'")

    gen["ckms_rootdir"] = str(opt_rootdir)
    gen["ckms_destdir"] = str(opt_destdir)

    # when not registering, we want modpath not to point to the source
    if by_name:
        modpath = modpath.parent

    return Module(gen["name"], gen["version"], modpath, modconf, mcfg)

def do_add(cmd):
    check_has_action(cmd)

    mod = read_module(cmd[1])

    # create module directory
    dbpath = opt_rootdir / mod.name / mod.version
    slpath = dbpath / "source"
    dbpath.mkdir(parents = True, exist_ok = True)
    # ensure it's not already added
    if slpath.is_dir() or (dbpath / "ckms.ini").is_file():
        raise CkmsError(f"{mod.modver} is already added")
    # create source symlink
    if slpath.exists() and not slpath.is_symlink():
        raise CkmsError(f"'{slpath}' exists but is not a symlink")
    slpath.symlink_to(mod.modpath)
    # install ckms.ini
    shutil.copy(mod.modconf, dbpath)

    log(f"added {mod.modver}")

def do_remove(cmd):
    check_has_action(cmd)

    mod = read_module(cmd[1], True)

    can_rm = True

    for f in mod.modpath.iterdir():
        if f.name == "source" or f.name == "build":
            continue
        log(f"{cmd[1]} still built for '{f.name}'")
        can_rm = False

    if not can_rm:
        raise CkmsError(f"'{mod.modpath}' has built modules")

    (mod.modpath / "source").unlink(missing_ok = True)

    if (mod.modpath / "build").is_dir():
        shutil.rmtree(mod.modpath / "build")

    mod.modpath.rmdir()

    log(f"removed {mod.modver}")

def do_clean(cmd):
    check_has_action(cmd)

    mod = read_module(cmd[1], True)

    kpath = mod.modpath / opt_kernver

    if not kpath.is_dir():
        raise CkmsError(f"{mod.modver} not built for {opt_kernver}")

    shutil.rmtree(kpath)

    log(f"cleaned {mod.modver} for {opt_kernver}")

def get_compsfx():
    if opt_comp:
        return f".{opt_comp}"
    # figure out whether to compress modules
    depf = kern_path / opt_kernver / "modules.dep"
    compsfx = None
    if depf:
        with open(depf) as df:
            for l in df:
                if l.find(".ko.gz") > 0:
                    compsfx = ".gz"
                    break
                if l.find(".ko.xz") > 0:
                    compsfx = ".xz"
                    break
                if l.find(".ko.zst") > 0:
                    compsfx = ".zst"
                    break

    return compsfx

def do_build(cmd, quiet = False):
    check_has_action(cmd)

    mod = read_module(cmd[1], True)

    kernhdrs = kern_path / opt_kernver / "build"

    if not kernhdrs.is_dir():
        raise CkmsError(f"kernel headers not installed in '{kernhdrs}'")

    mod.ensure_builtins(kernhdrs, opt_arch, opt_kernver)

    bpath = mod.modpath / opt_kernver / opt_arch
    if bpath.is_dir():
        if not quiet:
            log(f"found built tree for {mod.modver}")
        return mod

    log("preparing build...")

    bdir = mod.modpath / "build"
    if not bdir.is_dir():
        shutil.copytree(mod.modpath / "source", mod.modpath / "build")

    log("configuring...")

    mod.run_hook("configure")

    log("building...")

    mod.run_hook("pre_build")

    if not mod.run_hook("build"):
        # default behavior
        raise CkmsError("default build hook not yet supported")

    mdestb = bpath / "module"
    if mdestb.is_dir():
        shutil.rmtree(mdestb)
    mdestb.mkdir(parents = True, exist_ok = True)

    mod.run_hook("post_build")

    log("registering...")

    for modn, mpath, mdest, dostrip in mod.modules:
        log(f"registering kernel module '{modn}'")
        modf = bdir / mpath / f"{modn}.ko"
        destf = bpath / mpath
        if not modf.is_file():
            raise CkmsError(f"kernel module '{modn}' does not exist")
        # strip first
        if dostrip or (mod.strip and dostrip != False):
            if mod.do(opt_stripbin, "-g", modf).returncode != 0:
                raise CkmsError(f"strip failed for '{modf}'")
        # then copy
        destf.mkdir(parents = True, exist_ok = True)
        shutil.copy(modf, destf)
        (destf / f"{modn}.ko").chmod(0o644)

    # clean build dir
    shutil.rmtree(bdir)

    # move logs dir into kernel-specific dir
    if (mod.modpath / "logs").is_dir():
        shutil.move(mod.modpath / "logs", bpath)

    log(f"built {mod.modver} for {opt_kernver}/{opt_arch}")

    return mod

def do_depmod():
    rdest = opt_destdir.resolve()
    kdest = pathlib.Path("/lib/modules").resolve()

    if opt_depmod and rdest == kdest:
        dargs = ["-a"]
        smap = pathlib.Path(f"/boot/System.map-{opt_kernver}")
        if smap.is_file():
            dargs += ["-F", smap]
        if mod.do("depmod", *dargs, cwd = rdest).returncode != 0:
            raise CkmsError(f"depmod failed for {opt_kernver}")

def do_install(cmd):
    check_has_action(cmd, False)

    mod = read_module(cmd[1], True)

    kernhdrs = kern_path / opt_kernver / "build"

    mod.ensure_builtins(kernhdrs, opt_arch, opt_kernver)

    bpath = mod.modpath / opt_kernver / opt_arch
    if not bpath.is_dir():
        raise CkmsError(f"module {mod.modver} is not built")

    slinkn = f"kernel-{opt_kernver}-{opt_arch}"
    slinkd = f"{mod.version}/{opt_kernver}/{opt_arch}"
    slinkp = mod.modpath.parent / slinkn

    if slinkp.is_symlink():
        log(f"'{mod.modver}' already installed for {opt_kernver}")
        return

    log(f"installing {mod.modver} for {opt_kernver}/{opt_arch}")

    csfx = get_compsfx()

    for modn, mpath, mdest, dostrip in mod.modules:
        spath = bpath / mpath
        dpath = opt_destdir / opt_kernver / mdest
        modf = f"{modn}.ko"
        # clean up
        dpath.mkdir(exist_ok = True, parents = True)
        # remove modules, potentially compressed
        for f in dpath.glob(f"{modn}.ko*"):
            f.unlink()
        # copy the file, validate just in case
        if not (spath / modf).exists():
            raise CkmsError(f"module '{modf}' does not exist")
        shutil.copy(spath / modf, dpath)
        # compress
        if csfx == ".gz":
            compret = mod.do("gzip", "-9f", modf, cwd = dpath).returncode
        elif csfx == ".xz":
            compret = mod.do("xz", "-f", modf, cwd = dpath).returncode
        elif csfx == ".zst":
            compret = mod.do(
                "zstd", "-q", "-f", "-T0", "-20", "--ultra",
                modf, cwd = dpath
            ).returncode
        else:
            compret = 0
        # ensure this worked
        if compret != 0:
            raise CkmsError(f"module compression failed for '{modf}'")

    do_depmod()

    slinkp.symlink_to(slinkd)

    log(f"installed {mod.modver} for {opt_kernver}/{opt_arch}")

def do_uninstall(cmd):
    check_has_action(cmd, False)

    kernpath = opt_destdir / opt_kernver

    if not kernpath.is_dir():
        raise CkmsError(f"kernel modules not found in '{kernpath}'")

    mod = read_module(cmd[1], True)

    kernhdrs = kern_path / opt_kernver / "build"

    mod.ensure_builtins(kernhdrs, opt_arch, opt_kernver)

    for modn, mpath, mdest, dostrip in mod.modules:
        dpath = opt_destdir / opt_kernver / mdest
        if not dpath.is_dir():
            continue
        # remove modules, potentially compressed
        for f in dpath.glob(f"{modn}.ko*"):
            f.unlink()
        # try removing empty
        try:
            while dpath.is_relative_to(opt_destdir):
                os.rmdir(dpath)
                dpath = dpath.parent
        except OSError:
            # stop at first non-empty
            pass

    slinkn = f"kernel-{opt_kernver}-{opt_arch}"
    slinkp = mod.modpath.parent / slinkn
    slinkp.unlink(missing_ok = True)

    do_depmod()

    log(f"uninstalled {mod.modver} for {opt_kernver}")

def do_status(cmd):
    if len(cmd) < 2:
        module = None
    else:
        module = cmd[1]

    modver = None

    if module:
        eq = module.find("=")
        if eq > 0:
            modver = module[eq + 1:]
            module = module[0:eq]

    # just in case
    drop_privs()

    for f in opt_rootdir.iterdir():
        # just skip over junk
        if not f.is_dir():
            continue
        modname = f.name
        # specific module was given
        if module and modname != module:
            continue
        # otherwise loop for versions
        for v in f.iterdir():
            # ditto
            if not v.is_dir():
                continue
            version = v.name
            # specfic module version was given
            if modver and version != modver:
                continue
            # broken; ignore
            if not (v / "source").is_dir():
                continue
            # baseline state
            state = "added"
            if (v / opt_kernver / opt_arch).is_dir():
                # built or better
                state = "built"
                # check if it's installed too
                if (f / f"kernel-{opt_kernver}-{opt_arch}").is_symlink():
                    state = "installed"
            # print whatever state we got
            print(f"{modname}, {version}, {opt_kernver}, {opt_arch}: {state}")

def main():
    global opt_confpath, opt_kernver, opt_modconf, opt_quiet
    global opt_depmod, opt_arch, opt_jobs, opt_comp, opt_rootdir, opt_destdir
    global use_colors, opt_stripbin

    parser = argparse.ArgumentParser(
        description = "Chimera Kernel Module System"
    )
    # optional args
    parser.add_argument(
        "-C", "--config", default = opt_confpath,
        help = f"Path to CKMS configuration file (default: {opt_confpath})."
    )
    parser.add_argument(
        "-k", "--kernver", default = None,
        help = "Kernel version to use (default: current kernel)."
    )
    parser.add_argument(
        "-c", "--modconf", default = None,
        help = "Module config file to use (default: use stored)",
    )
    parser.add_argument(
        "-x", "--compression", default = None,
        help = "Compression method for modules (gz, xz or zst)"
    )
    parser.add_argument(
        "-q", "--quiet", action = "store_const", const = True,
        default = opt_quiet, help = "Do not log build output to stdout."
    )
    parser.add_argument(
        "-D", "--no-depmod", action = "store_const", const = True,
        default = not opt_depmod, help = "Do not run depmod after install."
    )
    parser.add_argument(
        "-j", "--jobs", default = None,
        help = "Number of build jobs (default: number of CPUs)"
    )
    parser.add_argument(
        "-s", "--statedir", default = None,
        help = "The CKMS state directory (default: /var/lib/ckms)"
    )
    parser.add_argument(
        "-d", "--destdir", default = None,
        help = f"Destination root for kernel modules (default: {opt_destdir})"
    )
    parser.add_argument(
        "-L", "--no-color", action = "store_const", const = True,
        default = False, help = "Force plain output."
    )
    # positional args
    parser.add_argument(
        "command", nargs = "+",
        help = "The command to issue, followed by its argument(s)."
    )

    cmdline = parser.parse_args()

    gcfg = configparser.ConfigParser(default_section = "ckms")
    gcfg.read(cmdline.config)

    ckcfg = gcfg["ckms"]

    opt_rootdir = pathlib.Path(ckcfg.get("statedir", fallback = opt_rootdir))
    opt_destdir = pathlib.Path(ckcfg.get("destdir", fallback = opt_destdir))
    opt_quiet = ckcfg.getboolean("quiet", fallback = False)
    opt_stripbin = ckcfg.get("strip", fallback = opt_stripbin)

    # TODO read the cfg

    # command line args override everything

    if cmdline.kernver:
        opt_kernver = cmdline.kernver

    if cmdline.modconf:
        opt_modconf = cmdline.modconf

    if cmdline.quiet:
        opt_quiet = True

    if cmdline.no_depmod:
        opt_depmod = False

    if cmdline.destdir:
        opt_destdir = pathlib.Path(cmdline.destdir)

    if cmdline.statedir:
        opt_rootdir = pathlib.Path(cmdline.statedir)

    if cmdline.jobs:
        opt_jobs = int(cmdline.jobs)

    if cmdline.compression:
        opt_comp = cmdline.compression

    # some reasonable defaults

    if not opt_jobs:
        opt_jobs = os.cpu_count()
    if not opt_jobs:
        opt_jobs = 1

    if not opt_kernver:
        opt_kernver = os.uname().release

    if not opt_arch:
        opt_arch = os.uname().machine

    if "NO_COLOR" in os.environ or not sys.stdout.isatty() or cmdline.no_color:
        use_colors = False

    if not opt_rootdir.is_dir():
        log_red(f"ERROR: state directory '{opt_rootdir}' does not exist")
        return 1

    comps = {
        "gz": True,
        "xz": True,
        "zst": True,
    }
    if opt_comp and opt_comp not in comps:
        log_red(f"ERROR: invalid compression method {opt_comp}")
        return 1

    # match the action

    try:
        action = cmdline.command[0]
        if action == "add":
            # add a module into the system
            do_add(cmdline.command)
        elif action == "remove":
            # remove a module from the system
            do_remove(cmdline.command)
        elif action == "install":
            # install a module for the given kernel
            do_install(cmdline.command)
        elif action == "uninstall":
            # uninstall a module from the given kernel
            do_uninstall(cmdline.command)
        elif action == "build":
            # build a module for the given kernel
            do_build(cmdline.command)
        elif action == "clean":
            # clean a module build for the given kernel
            do_clean(cmdline.command)
        elif action == "status":
            # print a module status for the given kernel
            do_status(cmdline.command)
        else:
            sys.stderr.write(
                f"Unknown action given: {cmdline.command[0]}\n"
            )
            return 1
    except CkmsError as e:
        log_red(f"ERROR: {e}")
        return 1
    except Exception:
        log_red(f"ERROR: internal error")
        traceback.print_exc()
        return 1

    return 0

sys.exit(main())

