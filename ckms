#!/usr/bin/env python3

import os
import sys
import shutil
import pathlib
import argparse
import traceback
import subprocess
import configparser

kern_path = pathlib.Path("/lib/modules")

opt_rootdir = pathlib.Path("/var/lib/ckms")
opt_destdir = kern_path

opt_confpath = "/etc/ckms.ini"
opt_kernver = None
opt_modconf = None
opt_quiet = False
opt_depmod = True
opt_arch = None
opt_jobs = None

use_colors = True

class CkmsError(Exception):
    pass

def log(msg, col = "\033[1m"):
    if use_colors:
        sys.stdout.write(col)
    sys.stdout.write("=> ckms: ")
    sys.stdout.write(msg)
    if use_colors:
        sys.stdout.write("\033[m")
    sys.stdout.write("\n");

def log_red(msg):
    log(msg, "\033[1m\033[31m")

def check_nonroot():
    if os.geteuid() == 0:
        raise CkmsError("please don't run this step as root")

def check_has_action(cmd):
    if len(cmd) < 2:
        raise CkmsError("action argument not given")

    check_nonroot()

class Module:
    def __init__(self, name, version, modpath, modconf, cfgdata):
        self.name = name
        self.version = version
        self.modver = f"{name}={version}"
        self.cfgdata = cfgdata
        self.modpath = modpath
        self.modconf = modconf
        self.env = {
            "PATH": os.environ["PATH"],
            "SHELL": "/bin/sh",
            "CKMS_MODNAME": name,
            "CKMS_MODVERSION": version,
            "CKMS_JOBS": str(opt_jobs),
            "CKMS_ROOTDIR": str(opt_rootdir),
            "CKMS_DESTDIR": str(opt_destdir),
        }
        if opt_depmod:
            self.env["CKMS_DEPMOD"] = "1"
        # save a list of modules
        self.modules = []
        modset = {}
        for sect in cfgdata.sections():
            if not sect.startswith("module."):
                continue
            sh = cfgdata[sect]
            mn = sect.removeprefix("module.")
            if "path" not in sh or "dest" not in sh:
                raise CkmsError(f"malformed module section '{sect}'")
            if mn in modset:
                raise CkmsError(f"duplicate module '{mn}'")
            self.modules.append((mn, sh["path"], sh["dest"]))
        # make deterministic
        self.modules.sort(key = lambda v: v[0])
        # ensure we have some modules
        if len(self.modules) == 0:
            raise CkmsError(f"'{self.name}' has no kernel modules")

    def ensure_builtins(self, kerndir, kernarch, kernver):
        gen = self.cfgdata["general"]
        gen["kernel_hdrdir"] = str(kerndir)
        gen["kernel_arch"] = kernarch
        gen["kernel_version"] = kernver
        # expose for hooks
        self.env["CKMS_KERNEL_HDRDIR"] = str(kerndir)
        self.env["CKMS_KERNEL"] = kernver
        self.env["CKMS_ARCH"] = kernarch

    def shell(self, s):
        return subprocess.run(
            s, shell = True, cwd = self.modpath / "build", env = self.env
        )

    def do(self, cmd, *args):
        return subprocess.run(
            [cmd, *args], cwd = self.modpath / "build", env = self.env
        )

    def run_hook(self, hookn):
        if "hooks" not in self.cfgdata:
            return False
        if hookn not in self.cfgdata["hooks"]:
            return False
        pret = self.shell(self.cfgdata["hooks"][hookn])
        if pret.returncode != 0:
            raise CkmsError(
                f"hook '{hookn}' failed with code {pret.returncode}"
            )
        return True

def get_modpath(namever):
    eq = namever.find("=")

    if eq < 0:
        raise CkmsError(f"'{namever}' does not match format 'name=version'")

    name = namever[0:eq]
    ver = namever[eq + 1:]

    if len(name) == 0 or len(ver) == 0:
        raise CkmsError(f"'{namever}' does not match format 'name=version'")

    return opt_rootdir / name / ver

def read_module(modpath, by_name = False):
    if by_name:
        modpath = get_modpath(modpath) / "source"
    else:
        modpath = pathlib.Path(modpath)

    if not modpath.is_dir():
        raise CkmsError(f"module path '{cmd[1]}' does not exist")

    modconf = opt_modconf
    if not modconf:
        modconf = modpath / "ckms.ini"

    modconf = pathlib.Path(modconf)

    if not modconf.is_file():
        raise CkmsError(f"module config file not found for '{cmd[1]}'")

    mcfg = configparser.ConfigParser(default_section = "general")
    mcfg.read(modconf)

    if not "general" in mcfg:
        raise CkmsError(f"general section missing for '{modconf}'")

    gen = mcfg["general"]

    if not "name" in gen:
        raise CkmsError(f"module name unknown for '{modconf}'")
    if not "version" in gen:
        raise CkmsError(f"module version unknown for '{modconf}'")

    gen["ckms_rootdir"] = str(opt_rootdir)
    gen["ckms_destdir"] = str(opt_destdir)

    # when not registering, we want modpath not to point to the source
    if by_name:
        modpath = modpath.parent

    return Module(gen["name"], gen["version"], modpath, modconf, mcfg)

def do_add(cmd):
    check_has_action(cmd)

    mod = read_module(cmd[1])

    # create module directory
    dbpath = opt_rootdir / mod.name / mod.version
    slpath = dbpath / "source"
    dbpath.mkdir(parents = True, exist_ok = True)
    # create source symlink
    if slpath.exists() and not slpath.is_symlink():
        raise CkmsError(f"'{slpath}' exists but is not a symlink")
    slpath.symlink_to(mod.modpath)

    log(f"added {mod.modver}")

def do_remove(cmd):
    check_has_action(cmd)

    mod = read_module(cmd[1], True)

    can_rm = True

    for f in mod.modpath.iterdir():
        if f.name == "source" or f.name == "build":
            continue
        log(f"{cmd[1]} still built for '{f.name}'")
        can_rm = False

    if not can_rm:
        raise CkmsError(f"'{mod.modpath}' has built modules")

    (mod.modpath / "source").unlink(missing_ok = True)

    if (mod.modpath / "build").is_dir():
        shutil.rmtree(mod.modpath / "build")

    mod.modpath.rmdir()

    log(f"removed {mod.modver}")

def do_clean(cmd):
    check_has_action(cmd)

    mod = read_module(cmd[1], True)

    kpath = mod.modpath / opt_kernver

    if not kpath.is_dir():
        raise CkmsError(f"{mod.modver} not built for {opt_kernver}")

    shutil.rmtree(kpath)

    log(f"cleaned {mod.modver} for {opt_kernver}")

def do_build(cmd, quiet = False):
    check_has_action(cmd)

    mod = read_module(cmd[1], True)

    kernhdrs = kern_path / opt_kernver / "build"

    if not kernhdrs.is_dir():
        raise CkmsError(f"kernel headers not installed in '{kernhdrs}'")

    mod.ensure_builtins(kernhdrs, opt_arch, opt_kernver)

    bpath = mod.modpath / opt_kernver / opt_arch
    if bpath.is_dir():
        if not quiet:
            log(f"found built tree for {mod.modver}")
        return mod

    log("preparing build...")

    bdir = mod.modpath / "build"
    # clean first if present
    if bdir.is_dir():
        shutil.rmtree(bdir)
    # copy
    shutil.copytree(mod.modpath / "source", mod.modpath / "build")

    log("configuring...")

    mod.run_hook("configure")

    log("building...")

    mod.run_hook("pre_build")

    if not mod.run_hook("build"):
        # default behavior
        raise CkmsError("default build hook not yet supported")

    mdestb = bpath / "module"
    if mdestb.is_dir():
        shutil.rmtree(mdestb)
    mdestb.mkdir(parents = True, exist_ok = True)

    mod.run_hook("post_build")

    log("registering...")

    for modn, mpath, mdest in mod.modules:
        log(f"registering kernel module '{modn}'")
        modf = bdir / mpath / f"{modn}.ko"
        destf = mdestb / mpath
        if not modf.is_file():
            raise CkmsError(f"kernel module '{modn}' does not exist")
        # strip first
        mod.do("strip", "-g", modf)
        # then copy
        destf.mkdir(parents = True, exist_ok = True)
        shutil.copy(modf, destf)
        (destf / f"{modn}.ko").chmod(0o644)

    log(f"built {mod.modver} for {opt_kernver}/{opt_arch}")

    return mod

def do_install(cmd):
    # can/often should run this one as root
    # previous actions must be completed first
    if len(cmd) < 2:
        raise CkmsError("action argument not given")

    mod = read_module(cmd[1], True)

    kernhdrs = kern_path / opt_kernver / "build"

    mod.ensure_builtins(kernhdrs, opt_arch, opt_kernver)

    bpath = mod.modpath / opt_kernver / opt_arch
    if not bpath.is_dir():
        raise CkmsError(f"module {mod.modver} is not built")

    slinkn = f"kernel-{opt_kernver}-{opt_arch}"
    slinkd = f"{mod.version}/{opt_kernver}/{opt_arch}"
    slinkp = mod.modpath.parent / slinkn

    if slinkp.is_symlink():
        log(f"'{mod.modver}' already installed for {opt_kernver}")
        return

    log(f"installing {mod.modver} for {opt_kernver}/{opt_arch}")

    for modn, mpath, mdest in mod.modules:
        spath = bpath / "module" / mpath
        dpath = opt_destdir / opt_kernver / mdest
        modf = f"{modn}.ko"
        # clean up
        dpath.mkdir(exist_ok = True, parents = True)
        (dpath / modf).unlink(missing_ok = True)
        # copy the file
        shutil.copy(spath / modf, dpath)

    slinkp.symlink_to(slinkd)

    log(f"installed {mod.modver} for {opt_kernver}/{opt_arch}")

def do_uninstall(cmd):
    if len(cmd) < 2:
        raise CkmsError("module name/version not given")

    kernpath = opt_destdir / opt_kernver

    if not kernpath.is_dir():
        raise CkmsError(f"kernel modules not found in '{kernpath}'")

    log(f"uninstalled {mod.modver} for {opt_kernver}")

def do_status(cmd):
    pass

def main():
    global opt_confpath, opt_kernver, opt_modconf, opt_quiet
    global opt_depmod, opt_arch, opt_jobs
    global use_colors

    parser = argparse.ArgumentParser(
        description = "Chimera Kernel Module System"
    )
    # optional args
    parser.add_argument(
        "-C", "--config", default = opt_confpath,
        help = f"Path to CKMS configuration file (default: {opt_confpath})."
    )
    parser.add_argument(
        "-k", "--kernver", default = None,
        help = "Kernel version to use (default: current kernel)."
    )
    parser.add_argument(
        "-c", "--modconf", default = None,
        help = "Module config file to use (default: modpath/ckms.ini)",
    )
    parser.add_argument(
        "-q", "--quiet", action = "store_const", const = True,
        default = opt_quiet, help = "Do not log build output to stdout."
    )
    parser.add_argument(
        "-D", "--no-depmod", action = "store_const", const = True,
        default = not opt_depmod, help = "Do not run depmod after install."
    )
    parser.add_argument(
        "-j", "--jobs", default = None,
        help = "Number of build jobs (default: number of CPUs)"
    )
    parser.add_argument(
        "-L", "--no-color", action = "store_const", const = True,
        default = False, help = "Force plain output."
    )
    # positional args
    parser.add_argument(
        "command", nargs = "+",
        help = "The command to issue, followed by its argument(s)."
    )

    cmdline = parser.parse_args()

    gcfg = configparser.ConfigParser()
    gcfg.read(cmdline.config)

    # TODO read the cfg

    # command line args override everything

    if cmdline.kernver:
        opt_kernver = cmdline.kernver

    if cmdline.modconf:
        opt_modconf = cmdline.modconf

    if cmdline.quiet:
        opt_quiet = True

    if cmdline.no_depmod:
        opt_depmod = False

    if cmdline.jobs:
        opt_jobs = int(cmdline.jobs)

    # some reasonable defaults

    if not opt_jobs:
        opt_jobs = os.cpu_count()
    if not opt_jobs:
        opt_jobs = 1

    if not opt_kernver:
        opt_kernver = os.uname().release

    if not opt_arch:
        opt_arch = os.uname().machine

    if "NO_COLOR" in os.environ or not sys.stdout.isatty() or cmdline.no_color:
        use_colors = False

    if not opt_rootdir.is_dir():
        raise CkmsError(f"state directory '{opt_rootdir}' does not exist")

    # match the action

    try:
        action = cmdline.command[0]
        if action == "add":
            # add a module into the system
            do_add(cmdline.command)
        elif action == "remove":
            # remove a module from the system
            do_remove(cmdline.command)
        elif action == "install":
            # install a module for the given kernel
            do_install(cmdline.command)
        elif action == "uninstall":
            # uninstall a module from the given kernel
            do_uninstall(cmdline.command)
        elif action == "build":
            # build a module for the given kernel
            do_build(cmdline.command)
        elif action == "clean":
            # clean a module build for the given kernel
            do_clean(cmdline.command)
        elif action == "status":
            # print a module status for the given kernel
            do_status(cmdline.command)
        else:
            sys.stderr.write(
                f"Unknown action given: {cmdline.command[0]}\n"
            )
            return 1
    except CkmsError as e:
        log_red(f"ERROR: {e}")
        return 1
    except:
        log_red(f"ERROR: internal error")
        traceback.print_exc()
        return 1

    return 0

sys.exit(main())

